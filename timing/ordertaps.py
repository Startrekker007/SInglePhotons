#!/usr/bin/python

# This program creates a VHDL entity that sorts the taps of the delay line
# by increasing delays, according to the Xilinx static timing model.
#
# 1. Create a design in ISE with the delay line only, for the targeted FPGA.
# If you run out of I/Os, connect some dummy logic to the taps to prevent
# optimizations. Use this Verilog source for example:
#module top(
#	input clk_i,
#	input reset_i,
#	input signal_i,
#	output xtap
#);
#
#wire [124*4-1:0] taps;
#
#tdc_delayline #(
#	.g_WIDTH(124)
#) dl (
#	.clk_i(clk_i),
#	.reset_i(reset_i),
#	.signal_i(signal_i),
#	.taps_o(taps)
#);
#
#assign xtap = |taps;
#
#endmodule
# 2. Apply this UCF constraint:
# NET "signal_i" OFFSET=IN 20 ns BEFORE "clk_i";
# 3. Implement the design.
# 4. Generate the XML timing report (.twx): trce -v 1000 top.ncd
# 5. Process it with this program.

from xml.etree.ElementTree import ElementTree
import re

filename = "timing_1.rpx"
ucftime = 20.0

delays = []
tree = ElementTree()
tree.parse(filename)
paths = tree.findall("twBody/twVerboseRpt/twConst/twPathRpt")
for path in paths:
    dest = path.find("twConstOffIn/twDest").text
    slack = path.find("twConstOffIn/twSlack").text
    destn = int(re.split("\[|\]", dest)[1])
    time = ucftime - float(slack)
    delays.append((destn, time))

sdelays = sorted(delays, key=lambda dd: dd[1])
print( """
-- This file was autogenerated by ordertaps.py

library ieee;
use ieee.std_logic_1164.all;

library work;
use work.tdc_package.all;

entity tdc_ordertaps is
    generic(
        g_WIDTH: positive
    );
    port(
        unsorted_i : in std_logic_vector(4*g_WIDTH-1 downto 0);
        sorted_o   : out std_logic_vector(4*g_WIDTH-1 downto 0)
    );
end entity;

architecture rtl of tdc_ordertaps is
begin
""")
i = 0
for tap in sdelays:
    print ("    sorted_o(%d) <= unsorted_i(%d); -- %.3f ns" % (i, tap[0], tap[1]))
    i = i + 1
print ("""
end architecture;
""")
